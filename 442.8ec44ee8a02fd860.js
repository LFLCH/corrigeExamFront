(()=>{"use strict";function u(t){const e=new cv.Mat,l=t.type()%8,c=l<=cv.CV_8S?1:l<=cv.CV_32S?1/256:255,x=l===cv.CV_8S||l===cv.CV_16S?128:0;switch(t.convertTo(e,cv.CV_8U,c,x),e.type()){case cv.CV_8UC1:cv.cvtColor(e,e,cv.COLOR_GRAY2RGBA);break;case cv.CV_8UC3:cv.cvtColor(e,e,cv.COLOR_RGB2RGBA);break;case cv.CV_8UC4:break;default:throw new Error("Bad number of channels (Source image must have 1, 3 or 4 channels)")}const H=new ImageData(new Uint8ClampedArray(e.data),e.cols,e.rows);return e.delete(),H}addEventListener("message",t=>{switch(t.data.msg){case"hello":postMessage({msg:`worker response to ${t.data.msg}`,uid:t.data.uid});break;case"load":{const e=self;e.Module={scriptUrl:"content/opencv/4/opencv.js",onRuntimeInitialized(){cv.then(l=>{cv=l,l.ready.then(()=>postMessage({msg:"opencvready",uid:t.data.uid}))})}},self.importScripts(e.Module.scriptUrl);break}case"imageProcessing":return function q(t){const e=cv.matFromImageData(t.payload);let l=new cv.Mat;cv.cvtColor(e,l,cv.COLOR_BGR2GRAY),postMessage({msg:t.msg,payload:u(l),uid:t.uid}),e.delete(),l.delete()}(t.data);case"imageAlignement":return function Z(t){if(t.payload.marker){const e=function $(t){let v,p,b,_,R,U,G,n,d,M,y,N,e=cv.matFromImageData(t.imageA),l=new cv.Mat,c=new cv.Mat;cv.cvtColor(e,e,cv.COLOR_RGBA2GRAY),cv.HoughCircles(e,c,cv.HOUGH_GRADIENT,1,45,75,20,6*e.cols/1e3,20*e.cols/1e3),c.cols>0&&(v=c.data32F[0],p=c.data32F[1],b=c.data32F[2],_=c.data32F[0],R=c.data32F[1],U=c.data32F[2],G=c.data32F[0],n=c.data32F[1],d=c.data32F[2],M=c.data32F[0],y=c.data32F[1],N=c.data32F[2]);const o=e.size().width,C=e.size().height;if(c.cols>0)for(let s=1;s<c.cols;s++){let a=c.data32F[3*s],i=c.data32F[3*s+1],w=c.data32F[3*s+2];a*a+i*i<=v*v+p*p&&(v=a,p=i,b=w),a*a+i*i>=M*M+y*y&&(M=a,y=i,N=w),(o-a)*(o-a)+i*i<=(o-_)*(o-_)+R*R&&(_=a,R=i,U=w),a*a+(C-i)*(C-i)<=G*G+(C-n)*(C-n)&&(G=a,n=i,d=w)}let g=cv.matFromImageData(t.imageB),k=new cv.Mat,f=new cv.Mat;cv.cvtColor(g,k,cv.COLOR_RGBA2GRAY);const z=k.size().width,O=k.size().height;cv.HoughCircles(k,f,cv.HOUGH_GRADIENT,1,45,75,15,d-3,d+3);let m=[],F=[];const B=150*(4*d*d-3.14159*d*d)/100;for(let s=0;s<f.cols;s++){let a=f.data32F[3*s],i=f.data32F[3*s+1],w=new cv.Rect(a-d,i-d,2*d,2*d),A=new cv.Mat;A=k.roi(w),cv.threshold(A,A,0,255,cv.THRESH_OTSU+cv.THRESH_BINARY),cv.countNonZero(A)<B&&(m.push(a),F.push(i)),A.delete()}let r,I,V,S,D,W,L,P;if(m.length>0&&(r=m[0],I=F[1],V=m[0],S=F[1],D=m[0],W=F[1],L=m[0],P=F[1]),m.length>1)for(let s=0;s<m.length;s++){let a=m[s],i=F[s];a*a+i*i<=r*r+I*I&&(r=a,I=i),a*a+i*i>=L*L+P*P&&(L=a,P=i),(z-a)*(z-a)+i*i<=(z-V)*(z-V)+S*S&&(V=a,S=i),a*a+(O-i)*(O-i)<=D*D+(O-W)*(O-W)&&(D=a,W=i)}let T=cv.matFromArray(4,1,cv.CV_32FC2,[v,p,_,R,G,n,M,y]),E=cv.matFromArray(4,1,cv.CV_32FC2,[r,I,V,S,D,W,L,P]),K=cv.findHomography(E,T,cv.RANSAC),Q=new cv.Size(e.cols,e.rows);if(K.empty())return void console.log("homography matrix empty!");cv.warpPerspective(g,l,K,Q);let Y=l.clone();for(let s=0;s<E.rows;++s){let w=15,A=new cv.Point(E.data32F[2*s],E.data32F[2*s+1]);cv.circle(g,A,w,[0,0,255,255],1)}for(let s=0;s<T.rows;++s){let w=15,A=new cv.Point(T.data32F[2*s],T.data32F[2*s+1]);cv.circle(e,A,w,[0,0,255,255],1),cv.circle(Y,A,w,[0,0,255,255],1)}let h={};return h.keypoints1=u(e),h.keypoints1Width=e.size().width,h.keypoints1Height=e.size().height,h.keypoints2=u(l),h.keypoints2Width=l.size().width,h.keypoints2Height=l.size().height,h.imageCompareMatches=u(g),h.imageCompareMatchesWidth=g.size().width,h.imageCompareMatchesHeight=g.size().height,h.imageAligned=u(Y),h.imageAlignedWidth=Y.size().width,h.imageAlignedHeight=Y.size().height,e.delete(),l.delete(),c.delete(),k.delete(),g.delete(),f.delete(),T.delete(),E.delete(),Y.delete(),h}(t.payload);postMessage({msg:t.msg,payload:e,uid:t.uid})}else{const e=function J(t,e){let l=cv.matFromImageData(t),c=cv.matFromImageData(e),x=new cv.Mat,H=new cv.Mat;cv.cvtColor(c,x,cv.COLOR_BGRA2GRAY),cv.cvtColor(l,H,cv.COLOR_BGRA2GRAY);let v=new cv.KeyPointVector,p=new cv.KeyPointVector,b=new cv.Mat,_=new cv.Mat,R=new cv.AKAZE,U=new cv.Mat,G=new cv.Mat;R.detectAndCompute(x,U,v,b),R.detectAndCompute(H,G,p,_);let n=new cv.DMatchVector,d=new cv.BFMatcher,M=new cv.DMatchVectorVector;d.knnMatch(b,_,M,2);for(let r=0;r<M.size();++r){let I=M.get(r),V=I.get(0),S=I.get(1);V.distance<=S.distance*parseFloat("0.7")&&n.push_back(V)}let y=new cv.Mat,N=new cv.Scalar(0,255,0,255);cv.drawMatches(c,v,l,p,n,y,N);let o={};o.imageCompareMatches=u(y),o.imageCompareMatchesWidth=y.size().width,o.imageCompareMatchesHeight=y.size().height;let C=new cv.Mat,g=new cv.Mat,k=new cv.Scalar(0,255,0,255);cv.drawKeypoints(x,v,C,k),cv.drawKeypoints(H,p,g,k),o.keypoints1=u(C),o.keypoints1Width=C.size().width,o.keypoints1Height=C.size().height,o.keypoints2=u(g),o.keypoints2Width=g.size().width,o.keypoints2Height=g.size().height;let f=[],z=[];for(let r=0;r<n.size();r++)f.push(v.get(n.get(r).queryIdx).pt.x),f.push(v.get(n.get(r).queryIdx).pt.y),z.push(p.get(n.get(r).trainIdx).pt.x),z.push(p.get(n.get(r).trainIdx).pt.y);let O=new cv.Mat(f.length,1,cv.CV_32FC2);O.data32F.set(f);let m=new cv.Mat(z.length,1,cv.CV_32FC2);m.data32F.set(z);let F=cv.findHomography(O,m,cv.RANSAC);if(F.empty())return void console.log("homography matrix empty!");console.log("h:",F);let B=new cv.Mat;return cv.warpPerspective(c,B,F,l.size()),o.imageAligned=u(B),o.imageAlignedWidth=B.size().width,o.imageAlignedHeight=B.size().height,B.delete(),O.delete(),m.delete(),C.delete(),g.delete(),y.delete(),M.delete(),d.delete(),n.delete(),R.delete(),x.delete(),v.delete(),H.delete(),p.delete(),b.delete(),_.delete(),U.delete(),G.delete(),o}(t.payload.imageA,t.payload.imageB);postMessage({msg:t.msg,payload:e,uid:t.uid})}}(t.data);case"imageCrop":return function j(t){let e=new cv.Rect(t.payload.x,t.payload.y,t.payload.width,t.payload.height),l=new cv.Mat,c=cv.matFromImageData(t.payload.image);l=c.roi(e),postMessage({msg:t.msg,payload:u(l),uid:t.uid}),l.delete(),c.delete()}(t.data)}})})();