(()=>{"use strict";function m(a){const e=new cv.Mat,s=a.type()%8,c=s<=cv.CV_8S?1:s<=cv.CV_32S?1/256:255,B=s===cv.CV_8S||s===cv.CV_16S?128:0;switch(a.convertTo(e,cv.CV_8U,c,B),e.type()){case cv.CV_8UC1:cv.cvtColor(e,e,cv.COLOR_GRAY2RGBA);break;case cv.CV_8UC3:cv.cvtColor(e,e,cv.COLOR_RGB2RGBA);break;case cv.CV_8UC4:break;default:throw new Error("Bad number of channels (Source image must have 1, 3 or 4 channels)")}const S=new ImageData(new Uint8ClampedArray(e.data),e.cols,e.rows);return e.delete(),S}addEventListener("message",a=>{switch(a.data.msg){case"hello":postMessage({msg:`worker response to ${a.data.msg}`,uid:a.data.uid});break;case"load":{const e=self;e.Module={scriptUrl:"content/opencv/4/opencv.js",onRuntimeInitialized(){cv.then(s=>{cv=s,s.ready.then(()=>postMessage({msg:"opencvready",uid:a.data.uid}))})}},self.importScripts(e.Module.scriptUrl);break}case"imageProcessing":return function oe(a){const e=cv.matFromImageData(a.payload);let s=new cv.Mat;cv.cvtColor(e,s,cv.COLOR_BGR2GRAY),postMessage({msg:a.msg,payload:m(s),uid:a.uid}),e.delete(),s.delete()}(a.data);case"imageAlignement":return function ne(a){if(a.payload.marker){const e=function re(a){console.log(a.imageA);let w,M,L,V,I,N,D,v,r,k,_,Q,e=cv.matFromImageData(a.imageA),s=new cv.Mat,c=new cv.Mat;cv.cvtColor(e,e,cv.COLOR_RGBA2GRAY),cv.HoughCircles(e,c,cv.HOUGH_GRADIENT,1,45,75,20,6*e.cols/1e3,20*e.cols/1e3),c.cols>0&&(w=c.data32F[0],M=c.data32F[1],L=c.data32F[2],V=c.data32F[0],I=c.data32F[1],N=c.data32F[2],D=c.data32F[0],v=c.data32F[1],r=c.data32F[2],k=c.data32F[0],_=c.data32F[1],Q=c.data32F[2]);const o=e.size().width,z=e.size().height;if(c.cols>0)for(let l=1;l<c.cols;l++){let t=c.data32F[3*l],i=c.data32F[3*l+1],u=c.data32F[3*l+2];t*t+i*i<=w*w+M*M&&(w=t,M=i,L=u),t*t+i*i>=k*k+_*_&&(k=t,_=i,Q=u),(o-t)*(o-t)+i*i<=(o-V)*(o-V)+I*I&&(V=t,I=i,N=u),t*t+(z-i)*(z-i)<=D*D+(z-v)*(z-v)&&(D=t,v=i,r=u)}let g=cv.matFromImageData(a.imageB),y=new cv.Mat,F=new cv.Mat;cv.cvtColor(g,y,cv.COLOR_RGBA2GRAY);const G=y.size().width,b=y.size().height;cv.HoughCircles(y,F,cv.HOUGH_GRADIENT,1,45,75,15,r-3,r+3);let p=[],x=[];const K=150*(4*r*r-3.14159*r*r)/100;for(let l=0;l<F.cols;l++){let t=F.data32F[3*l],i=F.data32F[3*l+1],u=new cv.Rect(t-r,i-r,2*r,2*r),h=new cv.Mat;h=y.roi(u),cv.threshold(h,h,0,255,cv.THRESH_OTSU+cv.THRESH_BINARY),cv.countNonZero(h)<K&&(p.push(t),x.push(i)),h.delete()}let n,W,P,U,E,Y,q,Z;if(p.length>0&&(n=p[0],W=x[1],P=p[0],U=x[1],E=p[0],Y=x[1],q=p[0],Z=x[1]),p.length>1)for(let l=0;l<p.length;l++){let t=p[l],i=x[l];t*t+i*i<=n*n+W*W&&(n=t,W=i),t*t+i*i>=q*q+Z*Z&&(q=t,Z=i),(G-t)*(G-t)+i*i<=(G-P)*(G-P)+U*U&&(P=t,U=i),t*t+(b-i)*(b-i)<=E*E+(b-Y)*(b-Y)&&(E=t,Y=i)}if(p.length>=4){let l=cv.matFromArray(4,1,cv.CV_32FC2,[w,M,V,I,D,v,k,_]),t=cv.matFromArray(4,1,cv.CV_32FC2,[n,W,P,U,E,Y,q,Z]),i=cv.findHomography(t,l,cv.RANSAC),u=new cv.Size(e.cols,e.rows);if(i.empty())return void console.log("homography matrix empty!");cv.warpPerspective(g,s,i,u);let h=s.clone();for(let C=0;C<t.rows;++C){let O=15,R=new cv.Point(t.data32F[2*C],t.data32F[2*C+1]);cv.circle(g,R,O,[0,0,255,255],1)}for(let C=0;C<l.rows;++C){let O=15,R=new cv.Point(l.data32F[2*C],l.data32F[2*C+1]);cv.circle(e,R,O,[0,0,255,255],1),cv.circle(h,R,O,[0,0,255,255],1)}let d={};return d.keypoints1=m(e),d.keypoints1Width=e.size().width,d.keypoints1Height=e.size().height,d.keypoints2=m(s),d.keypoints2Width=s.size().width,d.keypoints2Height=s.size().height,d.imageCompareMatches=m(g),d.imageCompareMatchesWidth=g.size().width,d.imageCompareMatchesHeight=g.size().height,d.imageAligned=m(h),d.imageAlignedWidth=h.size().width,d.imageAlignedHeight=h.size().height,e.delete(),s.delete(),c.delete(),y.delete(),g.delete(),F.delete(),l.delete(),t.delete(),h.delete(),d}{let l=new cv.KeyPointVector,t=new cv.KeyPointVector,i=new cv.Mat,u=new cv.Mat,h=new cv.AKAZE,d=new cv.Mat,C=new cv.Mat;h.detectAndCompute(y,d,l,i),h.detectAndCompute(e,C,t,u);let f=new cv.DMatchVector,T=new cv.BFMatcher,O=new cv.DMatchVectorVector;T.knnMatch(i,u,O,2);for(let H=0;H<O.size();++H){let le=O.get(H),se=le.get(0),me=le.get(1);se.distance<=me.distance*parseFloat("0.7")&&f.push_back(se)}let R=new cv.Mat,he=new cv.Scalar(0,255,0,255);cv.drawMatches(g,l,e,t,f,R,he);let A={};A.imageCompareMatches=m(R),A.imageCompareMatchesWidth=R.size().width,A.imageCompareMatchesHeight=R.size().height;let j=new cv.Mat,$=new cv.Mat,ce=new cv.Scalar(0,255,0,255);cv.drawKeypoints(y,l,j,ce),cv.drawKeypoints(e,t,$,ce),A.keypoints1=m(j),A.keypoints1Width=j.size().width,A.keypoints1Height=j.size().height,A.keypoints2=m($),A.keypoints2Width=$.size().width,A.keypoints2Height=$.size().height;let X=[],ee=[];for(let H=0;H<f.size();H++)X.push(l.get(f.get(H).queryIdx).pt.x),X.push(l.get(f.get(H).queryIdx).pt.y),ee.push(t.get(f.get(H).trainIdx).pt.x),ee.push(t.get(f.get(H).trainIdx).pt.y);let te=new cv.Mat(X.length,1,cv.CV_32FC2);te.data32F.set(X);let ae=new cv.Mat(ee.length,1,cv.CV_32FC2);ae.data32F.set(ee);let ie=cv.findHomography(te,ae,cv.RANSAC);if(ie.empty())return void console.log("homography matrix empty!");console.log("h:",ie);let J=new cv.Mat;cv.warpPerspective(y,J,ie,e.size()),A.imageAligned=m(J),A.imageAlignedWidth=J.size().width,A.imageAlignedHeight=J.size().height,J.delete(),te.delete(),ae.delete(),j.delete(),$.delete(),R.delete(),O.delete(),T.delete(),f.delete(),h.delete(),l.delete(),t.delete(),i.delete(),u.delete(),d.delete(),C.delete(),e.delete(),s.delete(),c.delete(),y.delete(),g.delete(),F.delete()}}(a.payload);postMessage({msg:a.msg,payload:e,uid:a.uid})}else{const e=function ge(a,e){let s=cv.matFromImageData(a),c=cv.matFromImageData(e),B=new cv.Mat,S=new cv.Mat;cv.cvtColor(c,B,cv.COLOR_BGRA2GRAY),cv.cvtColor(s,S,cv.COLOR_BGRA2GRAY);let w=new cv.KeyPointVector,M=new cv.KeyPointVector,L=new cv.Mat,V=new cv.Mat,I=new cv.AKAZE,N=new cv.Mat,D=new cv.Mat;I.detectAndCompute(B,N,w,L),I.detectAndCompute(S,D,M,V);let v=new cv.DMatchVector,r=new cv.BFMatcher,k=new cv.DMatchVectorVector;r.knnMatch(L,V,k,2);for(let n=0;n<k.size();++n){let W=k.get(n),P=W.get(0),U=W.get(1);P.distance<=U.distance*parseFloat("0.7")&&v.push_back(P)}let _=new cv.Mat,Q=new cv.Scalar(0,255,0,255);cv.drawMatches(c,w,s,M,v,_,Q);let o={};o.imageCompareMatches=m(_),o.imageCompareMatchesWidth=_.size().width,o.imageCompareMatchesHeight=_.size().height;let z=new cv.Mat,g=new cv.Mat,y=new cv.Scalar(0,255,0,255);cv.drawKeypoints(B,w,z,y),cv.drawKeypoints(S,M,g,y),o.keypoints1=m(z),o.keypoints1Width=z.size().width,o.keypoints1Height=z.size().height,o.keypoints2=m(g),o.keypoints2Width=g.size().width,o.keypoints2Height=g.size().height;let F=[],G=[];for(let n=0;n<v.size();n++)F.push(w.get(v.get(n).queryIdx).pt.x),F.push(w.get(v.get(n).queryIdx).pt.y),G.push(M.get(v.get(n).trainIdx).pt.x),G.push(M.get(v.get(n).trainIdx).pt.y);let b=new cv.Mat(F.length,1,cv.CV_32FC2);b.data32F.set(F);let p=new cv.Mat(G.length,1,cv.CV_32FC2);p.data32F.set(G);let x=cv.findHomography(b,p,cv.RANSAC);if(x.empty())return void console.log("homography matrix empty!");console.log("h:",x);let K=new cv.Mat;return cv.warpPerspective(c,K,x,s.size()),o.imageAligned=m(K),o.imageAlignedWidth=K.size().width,o.imageAlignedHeight=K.size().height,K.delete(),b.delete(),p.delete(),z.delete(),g.delete(),_.delete(),k.delete(),r.delete(),v.delete(),I.delete(),B.delete(),w.delete(),S.delete(),M.delete(),L.delete(),V.delete(),N.delete(),D.delete(),o}(a.payload.imageA,a.payload.imageB);postMessage({msg:a.msg,payload:e,uid:a.uid})}}(a.data);case"imageCrop":return function de(a){let e=new cv.Rect(a.payload.x,a.payload.y,a.payload.width,a.payload.height),s=new cv.Mat,c=cv.matFromImageData(a.payload.image);s=c.roi(e),postMessage({msg:a.msg,payload:m(s),uid:a.uid}),s.delete(),c.delete()}(a.data)}})})();