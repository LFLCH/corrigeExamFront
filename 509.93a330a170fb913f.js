(()=>{"use strict";class ne{constructor(e){e?(this.alphabet="abcdefghijklmnopqrstuvwxyz",this.characters="0123456789"+this.alphabet.toUpperCase()+this.alphabet):this.characters="0123456789",this.isWarmedUp=this.loadModel(e).then().then(()=>console.info("Backend running on:",tf.getBackend()))}loadModel(e){return console.time("Load model"),e?tf.loadLayersModel("content/classifier/letteranddigitclassifier/model.json").then(l=>{this._model=l,console.timeEnd("Load model")}):tf.loadLayersModel("content/classifier/digitclassifier/model.json").then(l=>{this._model=l,console.timeEnd("Load model")})}warmUp(){console.time("Warmup"),this._model.predict(tf.randomNormal([1,28,28,1])).as1D().dataSync(),console.timeEnd("Warmup")}preprocessImage(e){const g=e.width>e.height,r=Math.round((Math.max(e.width,e.height)-Math.min(e.width,e.height))/2),m=g?[[r,r],[0,0],[0,0]]:[[0,0],[r,r],[0,0]];return tf.tidy(()=>{let h=tf.browser.fromPixels(e,1).pad(m,255);return h=tf.image.resizeBilinear(h,[24,24]).pad([[2,2],[2,2],[0,0]],255),h=tf.scalar(1).sub(h.toFloat().div(tf.scalar(255))),h.expandDims(0)})}predict(e){if(!this._model)return console.warn("Model not loaded yet!");const l=this.preprocessImage(e),c=this._model.predict(l).as1D(),f=c.argMax().dataSync()[0],g=c.max().dataSync()[0];return[this.characters[f],g]}}let te,ie;function se(i,e){let l=cv.matFromImageData(i.payload.image);const c=function ue(i){return i?(void 0===te&&(te=new ne(i)),te):(void 0===ie&&(ie=new ne(i)),ie)}(e);c.isWarmedUp.then(()=>{const f=re(l,i.payload.match,c,!0,e),g=re(l,i.payload.match,c,!1,e);f.solution[1]>g.solution[1]?(postMessage({msg:i.msg,payload:{debug:A(f.debug),solution:f.solution},uid:i.uid}),f.debug.delete(),g.debug.delete(),l.delete()):(postMessage({msg:i.msg,payload:{debug:A(g.debug),solution:g.solution},uid:i.uid}),f.debug.delete(),g.debug.delete(),l.delete())})}function A(i){const e=new cv.Mat,l=i.type()%8,c=l<=cv.CV_8S?1:l<=cv.CV_32S?1/256:255,f=l===cv.CV_8S||l===cv.CV_16S?128:0;switch(i.convertTo(e,cv.CV_8U,c,f),e.type()){case cv.CV_8UC1:cv.cvtColor(e,e,cv.COLOR_GRAY2RGBA);break;case cv.CV_8UC3:cv.cvtColor(e,e,cv.COLOR_RGB2RGBA);break;case cv.CV_8UC4:break;default:throw new Error("Bad number of channels (Source image must have 1, 3 or 4 channels)")}const g=new ImageData(new Uint8ClampedArray(e.data),e.cols,e.rows);return e.delete(),g}function re(i,e,l,c,f){const g=function ye(i,e,l){let o=i.clone(),P=new cv.Mat;cv.cvtColor(i,P,cv.COLOR_BGR2GRAY,0);let D=new cv.Mat;cv.threshold(P,D,0,255,cv.THRESH_BINARY_INV+cv.THRESH_OTSU);let G=new cv.Point(-1,-1);if(e){let v=new cv.Mat,R=new cv.Size(1,15),s=cv.getStructuringElement(cv.MORPH_RECT,R);cv.morphologyEx(D,v,cv.MORPH_OPEN,s,G,2,cv.BORDER_CONSTANT,cv.morphologyDefaultBorderValue());let E=new cv.MatVector,z=new cv.Mat;cv.findContours(v,E,z,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE);let I=new cv.Scalar(255,255,255);cv.drawContours(o,E,-1,I,4);let n=new cv.Mat,t=new cv.Size(15,1),a=cv.getStructuringElement(cv.MORPH_RECT,t),O=new cv.Point(-1,-1);cv.morphologyEx(D,n,cv.MORPH_OPEN,a,O,2,cv.BORDER_CONSTANT,cv.morphologyDefaultBorderValue());let u=new cv.MatVector,w=new cv.Mat;cv.findContours(n,u,w,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE);let k=new cv.Scalar(255,255,255);cv.drawContours(o,u,-1,k,4),v.delete(),E.delete(),z.delete(),s.delete(),n.delete(),u.delete(),w.delete(),a.delete()}let x=new cv.Size(3,3),y=cv.getStructuringElement(cv.MORPH_ELLIPSE,x),B=new cv.Mat,X=cv.Mat.ones(i.rows,i.cols,cv.CV_8UC3);X.setTo(new cv.Scalar(255,255,255)),cv.cvtColor(X,X,cv.COLOR_BGR2GRAY,0);let p=new cv.Mat;cv.cvtColor(o,p,cv.COLOR_BGR2GRAY,0);let T=new cv.Mat;cv.subtract(X,p,T,B,-1);let M=new cv.Mat;cv.dilate(T,M,y,G,3,cv.BORDER_CONSTANT,cv.morphologyDefaultBorderValue());let S=new cv.Mat,H=new cv.Mat;cv.bitwise_and(M,D,S),cv.morphologyEx(S,H,cv.MORPH_CLOSE,y,G,3,cv.BORDER_CONSTANT,cv.morphologyDefaultBorderValue());let V=new cv.Mat;cv.bitwise_and(H,D,V);let b=new cv.Mat;cv.subtract(X,V,b,B,-1);let _=new cv.MatVector,L=new cv.Mat;cv.findContours(V,_,L,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE);const W=new Map;let C=[];for(let v=0;v<_.size();v++){let R=_.get(v),s=cv.boundingRect(R);(s.width*s.height>150||s.height>10)&&(s.width>s.height?(s.y=s.y-(s.width-s.height)/2,s.height=s.width):(s.x=s.x-(s.height-s.width)/2,s.width=s.height),C.push(s))}C.forEach(v=>{let R=new cv.Scalar(0,0,0),s=new cv.Point(v.x,v.y),E=new cv.Point(v.x+v.width,v.y+v.height),z=new cv.Mat,I=new cv.Mat,n=new cv.Mat;z=b.roi(v);let t=new cv.Size(26,26);cv.resize(z,I,t,0,0,cv.INTER_AREA);let a=new cv.Scalar(255,0,0,255);cv.copyMakeBorder(I,n,1,1,1,1,cv.BORDER_CONSTANT,a),W.set(v,n),z.delete(),I.delete(),cv.rectangle(b,s,E,R,2,cv.LINE_AA,0)}),P.delete(),D.delete(),y.delete(),B.delete(),X.delete(),p.delete(),T.delete(),M.delete(),o.delete(),S.delete(),H.delete(),V.delete(),_.delete(),L.delete();let d=[...W];if(d.sort((v,R)=>v[0].x<R[0].x?-1:1),l&&d.length>3){const v=(d[d.length-1][0].x-d[0][0].x)/d.length;let R=v,s=0,E=0,z=800;const I=[];for(let t=0;t<d.length-1;t++){let a=d[t+1][0].x-d[t][0].x;a<R&&(R=a),a>1.7*v&&I.push(t),d[t][0].y<z&&(z=d[t][0].y),d[t][0].height>s&&(s=d[t][0].height),d[t][0].width>E&&(E=d[t][0].width)}const n=(d[d.length-1][0].x-d[0][0].x)/(d.length+I.length);I.forEach(t=>{let a=d[t][0].x+n,O=new cv.Scalar(0,0,0),u=new cv.Point(a,z),w=new cv.Point(a+E,z+s),k=new cv.Rect(a,z,E,s),F=new cv.Mat,j=new cv.Mat,U=new cv.Mat;F=b.roi(k);let Y=new cv.Size(26,26);cv.resize(F,j,Y,0,0,cv.INTER_AREA);let ae=new cv.Scalar(255,0,0,255);cv.copyMakeBorder(j,U,1,1,1,1,cv.BORDER_CONSTANT,ae),W.set(k,U),F.delete(),j.delete(),cv.rectangle(b,u,w,O,2,cv.LINE_AA,0)}),d=[...W],d.sort((t,a)=>t[0].x<a[0].x?-1:1)}return{letter:d,invert_final:b}}(i,!1,c);let r=[];e.forEach(h=>{r.push([h.padEnd(13," "),0])});const m=[];for(let h=0;h<g.letter.length;h++){let o=l.predict(A(g.letter[h][1]));f&&("1"===o[0]&&(o[0]="i"),"0"===o[0]&&(o[0]="o"),"5"===o[0]&&(o[0]="s"),"3"===o[0]&&(o[0]="b"),"9"===o[0]&&(o[0]="g")),m.push(o)}for(let h=0;h<r.length;h++){for(let o=0;o<13;o++)o<m.length&&(r[h][1]=r[h][0].substring(o,o+1).toLowerCase()===m[o][0].toLowerCase()?r[h][1]+m[o][1]:r[h][1]+(1-m[o][1])/35);r[h][1]=r[h][1]/m.length}return r.sort((h,o)=>h[1]<o[1]?1:-1),r[0][0]=r[0][0].trim(),{debug:g.invert_final,solution:r[0]}}addEventListener("message",i=>{switch(i.data.msg){case"hello":postMessage({msg:`worker response to ${i.data.msg}`,uid:i.data.uid});break;case"load":{const e=self;e.Module={scriptUrl:"content/opencv/4/opencv.js",onRuntimeInitialized(){cv.then(l=>{cv=l,l.ready.then(()=>postMessage({msg:"opencvready",uid:i.data.uid}))})}},e.importScripts(e.Module.scriptUrl),e.importScripts("https://cdn.jsdelivr.net/npm/@tensorflow/tfjs");break}case"imageProcessing":return function ge(i){const e=cv.matFromImageData(i.payload);let l=new cv.Mat;cv.cvtColor(e,l,cv.COLOR_BGR2GRAY),postMessage({msg:i.msg,payload:A(l),uid:i.uid}),e.delete(),l.delete()}(i.data);case"imageAlignement":return function me(i){if(i.payload.marker){const e=function we(i){let r,m,h,o,P,D,G,x,y,B,N,X,e=cv.matFromImageData(i.imageA),l=new cv.Mat,c=new cv.Mat;cv.cvtColor(e,e,cv.COLOR_RGBA2GRAY),cv.HoughCircles(e,c,cv.HOUGH_GRADIENT,1,45,75,20,6*e.cols/1e3,20*e.cols/1e3),c.cols>0&&(r=c.data32F[0],m=c.data32F[1],h=c.data32F[2],o=c.data32F[0],P=c.data32F[1],D=c.data32F[2],G=c.data32F[0],x=c.data32F[1],y=c.data32F[2],B=c.data32F[0],N=c.data32F[1],X=c.data32F[2]);const p=e.size().width,T=e.size().height;if(c.cols>0)for(let n=1;n<c.cols;n++){let t=c.data32F[3*n],a=c.data32F[3*n+1],O=c.data32F[3*n+2];t*t+a*a<=r*r+m*m&&(r=t,m=a,h=O),t*t+a*a>=B*B+N*N&&(B=t,N=a,X=O),(p-t)*(p-t)+a*a<=(p-o)*(p-o)+P*P&&(o=t,P=a,D=O),t*t+(T-a)*(T-a)<=G*G+(T-x)*(T-x)&&(G=t,x=a,y=O)}let M=cv.matFromImageData(i.imageB),S=new cv.Mat,H=new cv.Mat;cv.cvtColor(M,S,cv.COLOR_RGBA2GRAY);const V=S.size().width,b=S.size().height;cv.HoughCircles(S,H,cv.HOUGH_GRADIENT,1,45,75,15,y-3,y+3);let _=[],L=[];const W=150*(4*y*y-3.14159*y*y)/100;for(let n=0;n<H.cols;n++){let t=H.data32F[3*n],a=H.data32F[3*n+1],O=new cv.Rect(t-y,a-y,2*y,2*y),u=new cv.Mat;u=S.roi(O),cv.threshold(u,u,0,255,cv.THRESH_OTSU+cv.THRESH_BINARY),cv.countNonZero(u)<W&&(_.push(t),L.push(a)),u.delete()}let C,d,v,R,s,E,z,I;if(_.length>0&&(C=_[0],d=L[1],v=_[0],R=L[1],s=_[0],E=L[1],z=_[0],I=L[1]),_.length>1)for(let n=0;n<_.length;n++){let t=_[n],a=L[n];t*t+a*a<=C*C+d*d&&(C=t,d=a),t*t+a*a>=z*z+I*I&&(z=t,I=a),(V-t)*(V-t)+a*a<=(V-v)*(V-v)+R*R&&(v=t,R=a),t*t+(b-a)*(b-a)<=s*s+(b-E)*(b-E)&&(s=t,E=a)}if(_.length>=4){let n=cv.matFromArray(4,1,cv.CV_32FC2,[r,m,o,P,G,x,B,N]),t=cv.matFromArray(4,1,cv.CV_32FC2,[C,d,v,R,s,E,z,I]),a=cv.findHomography(t,n,cv.RANSAC),O=new cv.Size(e.cols,e.rows);if(a.empty())return void console.log("homography matrix empty!");cv.warpPerspective(M,l,a,O);let u=l.clone();for(let k=0;k<t.rows;++k){let U=15,Y=new cv.Point(t.data32F[2*k],t.data32F[2*k+1]);cv.circle(M,Y,U,[0,0,255,255],1)}for(let k=0;k<n.rows;++k){let U=15,Y=new cv.Point(n.data32F[2*k],n.data32F[2*k+1]);cv.circle(e,Y,U,[0,0,255,255],1),cv.circle(u,Y,U,[0,0,255,255],1)}let w={};return w.keypoints1=A(e),w.keypoints1Width=e.size().width,w.keypoints1Height=e.size().height,w.keypoints2=A(l),w.keypoints2Width=l.size().width,w.keypoints2Height=l.size().height,w.imageCompareMatches=A(M),w.imageCompareMatchesWidth=M.size().width,w.imageCompareMatchesHeight=M.size().height,w.imageAligned=A(u),w.imageAlignedWidth=u.size().width,w.imageAlignedHeight=u.size().height,e.delete(),l.delete(),c.delete(),S.delete(),M.delete(),H.delete(),n.delete(),t.delete(),u.delete(),w}{let n=new cv.KeyPointVector,t=new cv.KeyPointVector,a=new cv.Mat,O=new cv.Mat,u=new cv.AKAZE,w=new cv.Mat,k=new cv.Mat;u.detectAndCompute(S,w,n,a),u.detectAndCompute(e,k,t,O);let F=new cv.DMatchVector,j=new cv.BFMatcher,U=new cv.DMatchVectorVector;j.knnMatch(a,O,U,2);for(let q=0;q<U.size();++q){let he=U.get(q),ve=he.get(0),Me=he.get(1);ve.distance<=Me.distance*parseFloat("0.7")&&F.push_back(ve)}let Y=new cv.Mat,ae=new cv.Scalar(0,255,0,255);cv.drawMatches(M,n,e,t,F,Y,ae);let K={};K.imageCompareMatches=A(Y),K.imageCompareMatchesWidth=Y.size().width,K.imageCompareMatchesHeight=Y.size().height;let Z=new cv.Mat,$=new cv.Mat,de=new cv.Scalar(0,255,0,255);cv.drawKeypoints(S,n,Z,de),cv.drawKeypoints(e,t,$,de),K.keypoints1=A(Z),K.keypoints1Width=Z.size().width,K.keypoints1Height=Z.size().height,K.keypoints2=A($),K.keypoints2Width=$.size().width,K.keypoints2Height=$.size().height;let Q=[],ee=[];for(let q=0;q<F.size();q++)Q.push(n.get(F.get(q).queryIdx).pt.x),Q.push(n.get(F.get(q).queryIdx).pt.y),ee.push(t.get(F.get(q).trainIdx).pt.x),ee.push(t.get(F.get(q).trainIdx).pt.y);let le=new cv.Mat(Q.length,1,cv.CV_32FC2);le.data32F.set(Q);let ce=new cv.Mat(ee.length,1,cv.CV_32FC2);ce.data32F.set(ee);let oe=cv.findHomography(le,ce,cv.RANSAC);if(oe.empty())return void console.log("homography matrix empty!");console.log("h:",oe);let J=new cv.Mat;cv.warpPerspective(S,J,oe,e.size()),K.imageAligned=A(J),K.imageAlignedWidth=J.size().width,K.imageAlignedHeight=J.size().height,J.delete(),le.delete(),ce.delete(),Z.delete(),$.delete(),Y.delete(),U.delete(),j.delete(),F.delete(),u.delete(),n.delete(),t.delete(),a.delete(),O.delete(),w.delete(),k.delete(),e.delete(),l.delete(),c.delete(),S.delete(),M.delete(),H.delete()}}(i.payload);postMessage({msg:i.msg,payload:e,uid:i.uid})}else{const e=function fe(i,e){let l=cv.matFromImageData(i),c=cv.matFromImageData(e),f=new cv.Mat,g=new cv.Mat;cv.cvtColor(c,f,cv.COLOR_BGRA2GRAY),cv.cvtColor(l,g,cv.COLOR_BGRA2GRAY);let r=new cv.KeyPointVector,m=new cv.KeyPointVector,h=new cv.Mat,o=new cv.Mat,P=new cv.AKAZE,D=new cv.Mat,G=new cv.Mat;P.detectAndCompute(f,D,r,h),P.detectAndCompute(g,G,m,o);let x=new cv.DMatchVector,y=new cv.BFMatcher,B=new cv.DMatchVectorVector;y.knnMatch(h,o,B,2);for(let C=0;C<B.size();++C){let d=B.get(C),v=d.get(0),R=d.get(1);v.distance<=R.distance*parseFloat("0.7")&&x.push_back(v)}let N=new cv.Mat,X=new cv.Scalar(0,255,0,255);cv.drawMatches(c,r,l,m,x,N,X);let p={};p.imageCompareMatches=A(N),p.imageCompareMatchesWidth=N.size().width,p.imageCompareMatchesHeight=N.size().height;let T=new cv.Mat,M=new cv.Mat,S=new cv.Scalar(0,255,0,255);cv.drawKeypoints(f,r,T,S),cv.drawKeypoints(g,m,M,S),p.keypoints1=A(T),p.keypoints1Width=T.size().width,p.keypoints1Height=T.size().height,p.keypoints2=A(M),p.keypoints2Width=M.size().width,p.keypoints2Height=M.size().height;let H=[],V=[];for(let C=0;C<x.size();C++)H.push(r.get(x.get(C).queryIdx).pt.x),H.push(r.get(x.get(C).queryIdx).pt.y),V.push(m.get(x.get(C).trainIdx).pt.x),V.push(m.get(x.get(C).trainIdx).pt.y);let b=new cv.Mat(H.length,1,cv.CV_32FC2);b.data32F.set(H);let _=new cv.Mat(V.length,1,cv.CV_32FC2);_.data32F.set(V);let L=cv.findHomography(b,_,cv.RANSAC);if(L.empty())return void console.log("homography matrix empty!");console.log("h:",L);let W=new cv.Mat;return cv.warpPerspective(c,W,L,l.size()),p.imageAligned=A(W),p.imageAlignedWidth=W.size().width,p.imageAlignedHeight=W.size().height,W.delete(),b.delete(),_.delete(),T.delete(),M.delete(),N.delete(),B.delete(),y.delete(),x.delete(),P.delete(),f.delete(),r.delete(),g.delete(),m.delete(),h.delete(),o.delete(),D.delete(),G.delete(),p}(i.payload.imageA,i.payload.imageB);postMessage({msg:i.msg,payload:e,uid:i.uid})}}(i.data);case"imageCrop":return function pe(i){let e=new cv.Rect(i.payload.x,i.payload.y,i.payload.width,i.payload.height),l=new cv.Mat,c=cv.matFromImageData(i.payload.image);l=c.roi(e),postMessage({msg:i.msg,payload:A(l),uid:i.uid}),l.delete(),c.delete()}(i.data);case"nameprediction":return se(i.data,!0);case"ineprediction":return se(i.data,!1)}})})();