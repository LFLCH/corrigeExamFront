(()=>{"use strict";class de{constructor(e){e?(this.alphabet="abcdefghijklmnopqrstuvwxyz",this.characters="0123456789"+this.alphabet.toUpperCase()+this.alphabet):this.characters="0123456789",this.isWarmedUp=this.loadModel(e).then().then(()=>console.info("Backend running on:",tf.getBackend()))}loadModel(e){return console.time("Load model"),e?tf.loadLayersModel("js/letteranddigitclassifier/model.json").then(i=>{this._model=i,console.timeEnd("Load model")}):tf.loadLayersModel("js/digitclassifier/model.json").then(i=>{this._model=i,console.timeEnd("Load model")})}warmUp(){console.time("Warmup"),this._model.predict(tf.randomNormal([1,28,28,1])).as1D().dataSync(),console.timeEnd("Warmup")}preprocessImage(e){const s=e.width>e.height,v=Math.round((Math.max(e.width,e.height)-Math.min(e.width,e.height))/2),n=s?[[v,v],[0,0],[0,0]]:[[0,0],[v,v],[0,0]];return tf.tidy(()=>{let h=tf.browser.fromPixels(e,1).pad(n,255);return h=tf.image.resizeBilinear(h,[24,24]).pad([[2,2],[2,2],[0,0]],255),h=tf.scalar(1).sub(h.toFloat().div(tf.scalar(255))),h.expandDims(0)})}predict(e){if(!this._model)return console.warn("Model not loaded yet!");const i=this.preprocessImage(e),c=this._model.predict(i).as1D(),g=c.argMax().dataSync()[0],s=c.max().dataSync()[0],v=this.characters[g];return console.log("Predicted",v,"Probability",s),[v,s]}}function ce(a,e){let i=cv.matFromImageData(a.payload.image);const c=new de(e);c.isWarmedUp.then(()=>{const g=oe(i,a.payload.candidates,c,!0),s=oe(i,a.payload.candidates,c,!0);g.solution[1]>s.solution[1]?(postMessage({msg:a.msg,payload:{debug:z(g.debug),solution:g.solution},uid:a.uid}),g.debug.delete(),s.debug.delete(),i.delete()):(postMessage({msg:a.msg,payload:{debug:z(s.debug),solution:s.solution},uid:a.uid}),g.debug.delete(),s.debug.delete(),i.delete())})}function z(a){const e=new cv.Mat,i=a.type()%8,c=i<=cv.CV_8S?1:i<=cv.CV_32S?1/256:255,g=i===cv.CV_8S||i===cv.CV_16S?128:0;switch(a.convertTo(e,cv.CV_8U,c,g),e.type()){case cv.CV_8UC1:cv.cvtColor(e,e,cv.COLOR_GRAY2RGBA);break;case cv.CV_8UC3:cv.cvtColor(e,e,cv.COLOR_RGB2RGBA);break;case cv.CV_8UC4:break;default:throw new Error("Bad number of channels (Source image must have 1, 3 or 4 channels)")}const s=new ImageData(new Uint8ClampedArray(e.data),e.cols,e.rows);return e.delete(),s}function oe(a,e,i,c){const g=function ue(a,e,i){let F=a.clone(),V=new cv.Mat;cv.cvtColor(a,V,cv.COLOR_BGR2GRAY,0);let D=new cv.Mat;cv.threshold(V,D,0,255,cv.THRESH_BINARY_INV+cv.THRESH_OTSU);let G=new cv.Point(-1,-1);if(e){let d=new cv.Mat,C=new cv.Size(1,15),p=cv.getStructuringElement(cv.MORPH_RECT,C);cv.morphologyEx(D,d,cv.MORPH_OPEN,p,G,2,cv.BORDER_CONSTANT,cv.morphologyDefaultBorderValue());let E=new cv.MatVector,R=new cv.Mat;cv.findContours(d,E,R,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE);let P=new cv.Scalar(255,255,255);cv.drawContours(F,E,-1,P,4);let o=new cv.Mat,t=new cv.Size(15,1),l=cv.getStructuringElement(cv.MORPH_RECT,t),x=new cv.Point(-1,-1);cv.morphologyEx(D,o,cv.MORPH_OPEN,l,x,2,cv.BORDER_CONSTANT,cv.morphologyDefaultBorderValue());let u=new cv.MatVector,w=new cv.Mat;cv.findContours(o,u,w,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE);let S=new cv.Scalar(255,255,255);cv.drawContours(F,u,-1,S,4),d.delete(),E.delete(),R.delete(),p.delete(),o.delete(),u.delete(),w.delete(),l.delete()}let k=new cv.Size(1,1),y=cv.getStructuringElement(cv.MORPH_ELLIPSE,k),I=new cv.Mat,X=cv.Mat.ones(a.rows,a.cols,cv.CV_8UC3);X.setTo(new cv.Scalar(255,255,255)),cv.cvtColor(X,X,cv.COLOR_BGR2GRAY,0);let m=new cv.Mat;cv.cvtColor(F,m,cv.COLOR_BGR2GRAY,0);let N=new cv.Mat;cv.subtract(X,m,N,I,-1);let M=new cv.Mat;cv.dilate(N,M,y,G,1,cv.BORDER_CONSTANT,cv.morphologyDefaultBorderValue());let A=new cv.Mat,H=new cv.Mat;cv.bitwise_and(M,D,A),cv.morphologyEx(A,H,cv.MORPH_CLOSE,y,G,1,cv.BORDER_CONSTANT,cv.morphologyDefaultBorderValue());let T=new cv.Mat;cv.bitwise_and(H,D,T);let b=new cv.Mat;cv.subtract(X,T,b,I,-1);let f=new cv.MatVector,L=new cv.Mat;cv.findContours(T,f,L,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE);const W=new Map;let _=[];for(let d=0;d<f.size();d++){let C=f.get(d),p=cv.boundingRect(C);p.width*p.height>300&&_.push(p)}_.forEach(d=>{let C=new cv.Scalar(0,0,0),p=new cv.Point(d.x,d.y),E=new cv.Point(d.x+d.width,d.y+d.height),R=new cv.Mat,P=new cv.Mat,o=new cv.Mat;R=b.roi(d);let t=new cv.Size(26,26);cv.resize(R,P,t,0,0,cv.INTER_AREA);let l=new cv.Scalar(255,0,0,255);cv.copyMakeBorder(P,o,1,1,1,1,cv.BORDER_CONSTANT,l),W.set(d,o),R.delete(),P.delete(),cv.rectangle(b,p,E,C,2,cv.LINE_AA,0)}),a.delete(),V.delete(),D.delete(),y.delete(),I.delete(),X.delete(),m.delete(),N.delete(),M.delete(),F.delete(),A.delete(),H.delete(),T.delete(),f.delete(),L.delete();let r=[...W];if(r.sort((d,C)=>d[0].x<C[0].x?-1:1),i&&r.length>3){const d=(r[r.length-1][0].x-r[0][0].x)/r.length;let C=d,p=0,E=0,R=800;const P=[];for(let t=0;t<r.length-1;t++){let l=r[t+1][0].x-r[t][0].x;l<C&&(C=l),l>1.7*d&&P.push(t),r[t][0].y<R&&(R=r[t][0].y),r[t][0].height>p&&(p=r[t][0].height),r[t][0].width>E&&(E=r[t][0].width)}const o=(r[r.length-1][0].x-r[0][0].x)/(r.length+P.length);P.forEach(t=>{let l=r[t][0].x+o,x=new cv.Scalar(0,0,0),u=new cv.Point(l,R),w=new cv.Point(l+E,R+p),S=new cv.Rect(l,R,E,p),O=new cv.Mat,j=new cv.Mat,U=new cv.Mat;O=b.roi(S);let Y=new cv.Size(26,26);cv.resize(O,j,Y,0,0,cv.INTER_AREA);let te=new cv.Scalar(255,0,0,255);cv.copyMakeBorder(j,U,1,1,1,1,cv.BORDER_CONSTANT,te),W.set(S,U),O.delete(),j.delete(),cv.rectangle(b,u,w,x,2,cv.LINE_AA,0)}),r=[...W],r.sort((t,l)=>t[0].x<l[0].x?-1:1)}return{letter:r,invert_final:b}}(a,!1,c);let s=[];e.forEach(n=>{s.push([n.padEnd(13," "),0])});const v=[];for(let n=0;n<g.letter.length;n++){let h=i.predict(z(g.letter[n][1]));v.push(h)}for(let n=0;n<s.length;n++){for(let h=0;h<13;h++)h<v.length&&(s[n][1]=s[n][0].substring(h,h+1).toLowerCase()===v[h][0].toLowerCase()?s[n][1]+v[h][1]:s[n][1]+(1-v[h][1])/35);s[n][1]=s[n][1]/v.length}return s.sort((n,h)=>n[1]<h[1]?1:-1),{debug:g.invert_final,solution:s[0]}}addEventListener("message",a=>{switch(a.data.msg){case"hello":postMessage({msg:`worker response to ${a.data.msg}`,uid:a.data.uid});break;case"load":{const e=self;e.Module={scriptUrl:"content/opencv/4/opencv.js",onRuntimeInitialized(){cv.then(i=>{cv=i,i.ready.then(()=>postMessage({msg:"opencvready",uid:a.data.uid}))})}},e.importScripts(e.Module.scriptUrl);break}case"imageProcessing":return function ve(a){const e=cv.matFromImageData(a.payload);let i=new cv.Mat;cv.cvtColor(e,i,cv.COLOR_BGR2GRAY),postMessage({msg:a.msg,payload:z(i),uid:a.uid}),e.delete(),i.delete()}(a.data);case"imageAlignement":return function he(a){if(a.payload.marker){const e=function me(a){console.log(a.imageA);let v,n,h,F,V,D,G,k,y,I,B,X,e=cv.matFromImageData(a.imageA),i=new cv.Mat,c=new cv.Mat;cv.cvtColor(e,e,cv.COLOR_RGBA2GRAY),cv.HoughCircles(e,c,cv.HOUGH_GRADIENT,1,45,75,20,6*e.cols/1e3,20*e.cols/1e3),c.cols>0&&(v=c.data32F[0],n=c.data32F[1],h=c.data32F[2],F=c.data32F[0],V=c.data32F[1],D=c.data32F[2],G=c.data32F[0],k=c.data32F[1],y=c.data32F[2],I=c.data32F[0],B=c.data32F[1],X=c.data32F[2]);const m=e.size().width,N=e.size().height;if(c.cols>0)for(let o=1;o<c.cols;o++){let t=c.data32F[3*o],l=c.data32F[3*o+1],x=c.data32F[3*o+2];t*t+l*l<=v*v+n*n&&(v=t,n=l,h=x),t*t+l*l>=I*I+B*B&&(I=t,B=l,X=x),(m-t)*(m-t)+l*l<=(m-F)*(m-F)+V*V&&(F=t,V=l,D=x),t*t+(N-l)*(N-l)<=G*G+(N-k)*(N-k)&&(G=t,k=l,y=x)}let M=cv.matFromImageData(a.imageB),A=new cv.Mat,H=new cv.Mat;cv.cvtColor(M,A,cv.COLOR_RGBA2GRAY);const T=A.size().width,b=A.size().height;cv.HoughCircles(A,H,cv.HOUGH_GRADIENT,1,45,75,15,y-3,y+3);let f=[],L=[];const W=150*(4*y*y-3.14159*y*y)/100;for(let o=0;o<H.cols;o++){let t=H.data32F[3*o],l=H.data32F[3*o+1],x=new cv.Rect(t-y,l-y,2*y,2*y),u=new cv.Mat;u=A.roi(x),cv.threshold(u,u,0,255,cv.THRESH_OTSU+cv.THRESH_BINARY),cv.countNonZero(u)<W&&(f.push(t),L.push(l)),u.delete()}let _,r,d,C,p,E,R,P;if(f.length>0&&(_=f[0],r=L[1],d=f[0],C=L[1],p=f[0],E=L[1],R=f[0],P=L[1]),f.length>1)for(let o=0;o<f.length;o++){let t=f[o],l=L[o];t*t+l*l<=_*_+r*r&&(_=t,r=l),t*t+l*l>=R*R+P*P&&(R=t,P=l),(T-t)*(T-t)+l*l<=(T-d)*(T-d)+C*C&&(d=t,C=l),t*t+(b-l)*(b-l)<=p*p+(b-E)*(b-E)&&(p=t,E=l)}if(f.length>=4){let o=cv.matFromArray(4,1,cv.CV_32FC2,[v,n,F,V,G,k,I,B]),t=cv.matFromArray(4,1,cv.CV_32FC2,[_,r,d,C,p,E,R,P]),l=cv.findHomography(t,o,cv.RANSAC),x=new cv.Size(e.cols,e.rows);if(l.empty())return void console.log("homography matrix empty!");cv.warpPerspective(M,i,l,x);let u=i.clone();for(let S=0;S<t.rows;++S){let U=15,Y=new cv.Point(t.data32F[2*S],t.data32F[2*S+1]);cv.circle(M,Y,U,[0,0,255,255],1)}for(let S=0;S<o.rows;++S){let U=15,Y=new cv.Point(o.data32F[2*S],o.data32F[2*S+1]);cv.circle(e,Y,U,[0,0,255,255],1),cv.circle(u,Y,U,[0,0,255,255],1)}let w={};return w.keypoints1=z(e),w.keypoints1Width=e.size().width,w.keypoints1Height=e.size().height,w.keypoints2=z(i),w.keypoints2Width=i.size().width,w.keypoints2Height=i.size().height,w.imageCompareMatches=z(M),w.imageCompareMatchesWidth=M.size().width,w.imageCompareMatchesHeight=M.size().height,w.imageAligned=z(u),w.imageAlignedWidth=u.size().width,w.imageAlignedHeight=u.size().height,e.delete(),i.delete(),c.delete(),A.delete(),M.delete(),H.delete(),o.delete(),t.delete(),u.delete(),w}{let o=new cv.KeyPointVector,t=new cv.KeyPointVector,l=new cv.Mat,x=new cv.Mat,u=new cv.AKAZE,w=new cv.Mat,S=new cv.Mat;u.detectAndCompute(A,w,o,l),u.detectAndCompute(e,S,t,x);let O=new cv.DMatchVector,j=new cv.BFMatcher,U=new cv.DMatchVectorVector;j.knnMatch(l,x,U,2);for(let q=0;q<U.size();++q){let se=U.get(q),re=se.get(0),we=se.get(1);re.distance<=we.distance*parseFloat("0.7")&&O.push_back(re)}let Y=new cv.Mat,te=new cv.Scalar(0,255,0,255);cv.drawMatches(M,o,e,t,O,Y,te);let K={};K.imageCompareMatches=z(Y),K.imageCompareMatchesWidth=Y.size().width,K.imageCompareMatchesHeight=Y.size().height;let Z=new cv.Mat,$=new cv.Mat,ne=new cv.Scalar(0,255,0,255);cv.drawKeypoints(A,o,Z,ne),cv.drawKeypoints(e,t,$,ne),K.keypoints1=z(Z),K.keypoints1Width=Z.size().width,K.keypoints1Height=Z.size().height,K.keypoints2=z($),K.keypoints2Width=$.size().width,K.keypoints2Height=$.size().height;let Q=[],ee=[];for(let q=0;q<O.size();q++)Q.push(o.get(O.get(q).queryIdx).pt.x),Q.push(o.get(O.get(q).queryIdx).pt.y),ee.push(t.get(O.get(q).trainIdx).pt.x),ee.push(t.get(O.get(q).trainIdx).pt.y);let ae=new cv.Mat(Q.length,1,cv.CV_32FC2);ae.data32F.set(Q);let le=new cv.Mat(ee.length,1,cv.CV_32FC2);le.data32F.set(ee);let ie=cv.findHomography(ae,le,cv.RANSAC);if(ie.empty())return void console.log("homography matrix empty!");console.log("h:",ie);let J=new cv.Mat;cv.warpPerspective(A,J,ie,e.size()),K.imageAligned=z(J),K.imageAlignedWidth=J.size().width,K.imageAlignedHeight=J.size().height,J.delete(),ae.delete(),le.delete(),Z.delete(),$.delete(),Y.delete(),U.delete(),j.delete(),O.delete(),u.delete(),o.delete(),t.delete(),l.delete(),x.delete(),w.delete(),S.delete(),e.delete(),i.delete(),c.delete(),A.delete(),M.delete(),H.delete()}}(a.payload);postMessage({msg:a.msg,payload:e,uid:a.uid})}else{const e=function pe(a,e){let i=cv.matFromImageData(a),c=cv.matFromImageData(e),g=new cv.Mat,s=new cv.Mat;cv.cvtColor(c,g,cv.COLOR_BGRA2GRAY),cv.cvtColor(i,s,cv.COLOR_BGRA2GRAY);let v=new cv.KeyPointVector,n=new cv.KeyPointVector,h=new cv.Mat,F=new cv.Mat,V=new cv.AKAZE,D=new cv.Mat,G=new cv.Mat;V.detectAndCompute(g,D,v,h),V.detectAndCompute(s,G,n,F);let k=new cv.DMatchVector,y=new cv.BFMatcher,I=new cv.DMatchVectorVector;y.knnMatch(h,F,I,2);for(let _=0;_<I.size();++_){let r=I.get(_),d=r.get(0),C=r.get(1);d.distance<=C.distance*parseFloat("0.7")&&k.push_back(d)}let B=new cv.Mat,X=new cv.Scalar(0,255,0,255);cv.drawMatches(c,v,i,n,k,B,X);let m={};m.imageCompareMatches=z(B),m.imageCompareMatchesWidth=B.size().width,m.imageCompareMatchesHeight=B.size().height;let N=new cv.Mat,M=new cv.Mat,A=new cv.Scalar(0,255,0,255);cv.drawKeypoints(g,v,N,A),cv.drawKeypoints(s,n,M,A),m.keypoints1=z(N),m.keypoints1Width=N.size().width,m.keypoints1Height=N.size().height,m.keypoints2=z(M),m.keypoints2Width=M.size().width,m.keypoints2Height=M.size().height;let H=[],T=[];for(let _=0;_<k.size();_++)H.push(v.get(k.get(_).queryIdx).pt.x),H.push(v.get(k.get(_).queryIdx).pt.y),T.push(n.get(k.get(_).trainIdx).pt.x),T.push(n.get(k.get(_).trainIdx).pt.y);let b=new cv.Mat(H.length,1,cv.CV_32FC2);b.data32F.set(H);let f=new cv.Mat(T.length,1,cv.CV_32FC2);f.data32F.set(T);let L=cv.findHomography(b,f,cv.RANSAC);if(L.empty())return void console.log("homography matrix empty!");console.log("h:",L);let W=new cv.Mat;return cv.warpPerspective(c,W,L,i.size()),m.imageAligned=z(W),m.imageAlignedWidth=W.size().width,m.imageAlignedHeight=W.size().height,W.delete(),b.delete(),f.delete(),N.delete(),M.delete(),B.delete(),I.delete(),y.delete(),k.delete(),V.delete(),g.delete(),v.delete(),s.delete(),n.delete(),h.delete(),F.delete(),D.delete(),G.delete(),m}(a.payload.imageA,a.payload.imageB);postMessage({msg:a.msg,payload:e,uid:a.uid})}}(a.data);case"imageCrop":return function ge(a){let e=new cv.Rect(a.payload.x,a.payload.y,a.payload.width,a.payload.height),i=new cv.Mat,c=cv.matFromImageData(a.payload.image);i=c.roi(e),postMessage({msg:a.msg,payload:z(i),uid:a.uid}),i.delete(),c.delete()}(a.data);case"nameprediction":return ce(a.data,!0);case"ineprediction":return ce(a.data,!1)}})})();