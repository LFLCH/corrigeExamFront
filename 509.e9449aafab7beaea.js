(()=>{"use strict";class ne{constructor(e){e?(this.alphabet="abcdefghijklmnopqrstuvwxyz",this.characters="0123456789"+this.alphabet.toUpperCase()+this.alphabet):this.characters="0123456789",this.isWarmedUp=this.loadModel(e).then().then(()=>console.info("Backend running on:",tf.getBackend()))}loadModel(e){return console.time("Load model"),e?tf.loadLayersModel("content/classifier/letteranddigitclassifier/model.json").then(c=>{this._model=c,console.timeEnd("Load model")}):tf.loadLayersModel("content/classifier/digitclassifier/model.json").then(c=>{this._model=c,console.timeEnd("Load model")})}warmUp(){console.time("Warmup"),this._model.predict(tf.randomNormal([1,28,28,1])).as1D().dataSync(),console.timeEnd("Warmup")}preprocessImage(e){const k=e.width>e.height,r=Math.round((Math.max(e.width,e.height)-Math.min(e.width,e.height))/2),g=k?[[r,r],[0,0],[0,0]]:[[0,0],[r,r],[0,0]];return tf.tidy(()=>{let h=tf.browser.fromPixels(e,1).pad(g,255);return h=tf.image.resizeBilinear(h,[24,24]).pad([[2,2],[2,2],[0,0]],255),h=tf.scalar(1).sub(h.toFloat().div(tf.scalar(255))),h.expandDims(0)})}predict(e){if(!this._model)return console.warn("Model not loaded yet!");const c=this.preprocessImage(e),o=this._model.predict(c).as1D(),z=o.argMax().dataSync()[0],k=o.max().dataSync()[0];return[this.characters[z],k]}}let te,ie;function se(i,e){let c=cv.matFromImageData(i.payload.image);const o=function pe(i){return i?(void 0===te&&(te=new ne(i)),te):(void 0===ie&&(ie=new ne(i)),ie)}(e);o.isWarmedUp.then(()=>{const z=function fe(i,e,c,o,z){const k=function ye(i,e,c){let n=i.clone(),N=new cv.Mat;cv.cvtColor(i,N,cv.COLOR_BGR2GRAY,0);let G=new cv.Mat;cv.threshold(N,G,0,255,cv.THRESH_BINARY_INV+cv.THRESH_OTSU);let W=new cv.Point(-1,-1);if(e){let l=new cv.Mat,A=new cv.Size(1,15),w=cv.getStructuringElement(cv.MORPH_RECT,A);cv.morphologyEx(G,l,cv.MORPH_OPEN,w,W,2,cv.BORDER_CONSTANT,cv.morphologyDefaultBorderValue());let I=new cv.MatVector,x=new cv.Mat;cv.findContours(l,I,x,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE);let b=new cv.Scalar(255,255,255);cv.drawContours(n,I,-1,b,4);let s=new cv.Mat,t=new cv.Size(15,1),a=cv.getStructuringElement(cv.MORPH_RECT,t),R=new cv.Point(-1,-1);cv.morphologyEx(G,s,cv.MORPH_OPEN,a,R,2,cv.BORDER_CONSTANT,cv.morphologyDefaultBorderValue());let f=new cv.MatVector,v=new cv.Mat;cv.findContours(s,f,v,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE);let u=new cv.Scalar(255,255,255);cv.drawContours(n,f,-1,u,4),l.delete(),I.delete(),x.delete(),w.delete(),s.delete(),f.delete(),v.delete(),a.delete()}let F=new cv.Size(3,3),p=cv.getStructuringElement(cv.MORPH_ELLIPSE,F),T=new cv.Mat,j=cv.Mat.ones(i.rows,i.cols,cv.CV_8UC3);j.setTo(new cv.Scalar(255,255,255)),cv.cvtColor(j,j,cv.COLOR_BGR2GRAY,0);let m=new cv.Mat;cv.cvtColor(n,m,cv.COLOR_BGR2GRAY,0);let L=new cv.Mat;cv.subtract(j,m,L,T,-1);let y=new cv.Mat;cv.dilate(L,y,p,W,3,cv.BORDER_CONSTANT,cv.morphologyDefaultBorderValue());let E=new cv.Mat,B=new cv.Mat;cv.bitwise_and(y,G,E),cv.morphologyEx(E,B,cv.MORPH_CLOSE,p,W,3,cv.BORDER_CONSTANT,cv.morphologyDefaultBorderValue());let H=new cv.Mat;cv.bitwise_and(B,G,H);let M=new cv.Mat;cv.subtract(j,H,M,T,-1);let _=new cv.MatVector,D=new cv.Mat;cv.findContours(H,_,D,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE);const U=new Map;let C=[];for(let l=0;l<_.size();l++){let A=_.get(l),w=cv.boundingRect(A);(w.width>12||w.height>12)&&C.push(w)}C.forEach(l=>{let A=new cv.Scalar(0,0,0),w=new cv.Point(l.x,l.y),I=new cv.Point(l.x+l.width,l.y+l.height),x=new cv.Mat,b=new cv.Mat,s=new cv.Mat;const t=M.size().width,a=M.size().height;l.x+l.width>t&&(l.width=t-l.x),l.y+l.height>a&&(l.height=a-l.y),l.x<0&&(l.x=0),l.y<0&&(l.y=0),x=M.roi(l);let R=new cv.Size(26,26);cv.resize(x,b,R,0,0,cv.INTER_AREA);let f=new cv.Scalar(255,0,0,255);cv.copyMakeBorder(b,s,1,1,1,1,cv.BORDER_CONSTANT,f),U.set(l,s),x.delete(),b.delete(),cv.rectangle(M,w,I,A,2,cv.LINE_AA,0)}),N.delete(),G.delete(),p.delete(),T.delete(),j.delete(),m.delete(),L.delete(),y.delete(),n.delete(),E.delete(),B.delete(),H.delete(),_.delete(),D.delete();let d=[...U];if(d.sort((l,A)=>l[0].x<A[0].x?-1:1),c&&d.length>3){const l=(d[d.length-1][0].x-d[0][0].x)/d.length;let A=l,w=0,I=0,x=800;const b=[];for(let t=0;t<d.length-1;t++){let a=d[t+1][0].x-d[t][0].x;a<A&&(A=a),a>1.7*l&&b.push(t),d[t][0].y<x&&(x=d[t][0].y),d[t][0].height>w&&(w=d[t][0].height),d[t][0].width>I&&(I=d[t][0].width)}const s=(d[d.length-1][0].x-d[0][0].x)/(d.length+b.length);b.forEach(t=>{let a=d[t][0].x+s,R=new cv.Scalar(0,0,0),f=new cv.Point(a,x),v=new cv.Point(a+I,x+w),u=new cv.Rect(a,x,I,w),S=new cv.Mat,P=new cv.Mat,Y=new cv.Mat;S=M.roi(u);let K=new cv.Size(26,26);cv.resize(S,P,K,0,0,cv.INTER_AREA);let ae=new cv.Scalar(255,0,0,255);cv.copyMakeBorder(P,Y,1,1,1,1,cv.BORDER_CONSTANT,ae),U.set(u,Y),S.delete(),P.delete(),cv.rectangle(M,f,v,R,2,cv.LINE_AA,0)}),d=[...U],d.sort((t,a)=>t[0].x<a[0].x?-1:1)}return{letter:d,invert_final:M}}(i,!1,o);let r=[];e.forEach(h=>{r.push([h.padEnd(13," "),0])});const g=[];for(let h=0;h<k.letter.length;h++){let n=c.predict(O(k.letter[h][1]));z&&("1"===n[0]&&(n[0]="i"),"0"===n[0]&&(n[0]="o"),"5"===n[0]&&(n[0]="s"),"3"===n[0]&&(n[0]="b"),"9"===n[0]&&(n[0]="g")),g.push(n)}for(let h=0;h<r.length;h++){for(let n=0;n<13;n++)n<g.length&&(r[h][1]=r[h][0].substring(n,n+1).toLowerCase()===g[n][0].toLowerCase()?r[h][1]+g[n][1]:r[h][1]+(1-g[n][1])/35);r[h][1]=r[h][1]/g.length}return r.sort((h,n)=>h[1]<n[1]?1:-1),r[0][0]=r[0][0].trim(),{debug:k.invert_final,solution:r[0]}}(c,i.payload.match,o,!0,e);postMessage({msg:i.msg,payload:{debug:O(z.debug),solution:z.solution},uid:i.uid}),z.debug.delete(),c.delete()})}function O(i){const e=new cv.Mat,c=i.type()%8,o=c<=cv.CV_8S?1:c<=cv.CV_32S?1/256:255,z=c===cv.CV_8S||c===cv.CV_16S?128:0;switch(i.convertTo(e,cv.CV_8U,o,z),e.type()){case cv.CV_8UC1:cv.cvtColor(e,e,cv.COLOR_GRAY2RGBA);break;case cv.CV_8UC3:cv.cvtColor(e,e,cv.COLOR_RGB2RGBA);break;case cv.CV_8UC4:break;default:throw new Error("Bad number of channels (Source image must have 1, 3 or 4 channels)")}const k=new ImageData(new Uint8ClampedArray(e.data),e.cols,e.rows);return e.delete(),k}addEventListener("message",i=>{switch(i.data.msg){case"hello":postMessage({msg:`worker response to ${i.data.msg}`,uid:i.data.uid});break;case"load":{const e=self;e.Module={scriptUrl:"content/opencv/4/opencv.js",onRuntimeInitialized(){cv.then(c=>{cv=c,c.ready.then(()=>postMessage({msg:"opencvready",uid:i.data.uid}))})}},e.importScripts(e.Module.scriptUrl),e.importScripts("https://cdn.jsdelivr.net/npm/@tensorflow/tfjs");break}case"imageProcessing":return function ve(i){const e=cv.matFromImageData(i.payload);let c=new cv.Mat;cv.cvtColor(e,c,cv.COLOR_BGR2GRAY),postMessage({msg:i.msg,payload:O(c),uid:i.uid}),e.delete(),c.delete()}(i.data);case"imageAlignement":return function ge(i){if(i.payload.marker){const e=function we(i){let r,g,h,n,N,G,W,F,p,T,V,j,e=cv.matFromImageData(i.imageA),c=new cv.Mat,o=new cv.Mat;cv.cvtColor(e,e,cv.COLOR_RGBA2GRAY),cv.HoughCircles(e,o,cv.HOUGH_GRADIENT,1,45,75,20,6*e.cols/1e3,20*e.cols/1e3),o.cols>0&&(r=o.data32F[0],g=o.data32F[1],h=o.data32F[2],n=o.data32F[0],N=o.data32F[1],G=o.data32F[2],W=o.data32F[0],F=o.data32F[1],p=o.data32F[2],T=o.data32F[0],V=o.data32F[1],j=o.data32F[2]);const m=e.size().width,L=e.size().height;if(o.cols>0)for(let s=1;s<o.cols;s++){let t=o.data32F[3*s],a=o.data32F[3*s+1],R=o.data32F[3*s+2];t*t+a*a<=r*r+g*g&&(r=t,g=a,h=R),t*t+a*a>=T*T+V*V&&(T=t,V=a,j=R),(m-t)*(m-t)+a*a<=(m-n)*(m-n)+N*N&&(n=t,N=a,G=R),t*t+(L-a)*(L-a)<=W*W+(L-F)*(L-F)&&(W=t,F=a,p=R)}let y=cv.matFromImageData(i.imageB),E=new cv.Mat,B=new cv.Mat;cv.cvtColor(y,E,cv.COLOR_RGBA2GRAY);const H=E.size().width,M=E.size().height;cv.HoughCircles(E,B,cv.HOUGH_GRADIENT,1,45,75,15,p-3,p+3);let _=[],D=[];const U=150*(4*p*p-3.14159*p*p)/100;for(let s=0;s<B.cols;s++){let t=B.data32F[3*s],a=B.data32F[3*s+1];const R=t-p,f=a-p;let v=2*p,u=2*p;R+v>H&&(v=H-R),f+u>M&&(u=M-f);let S=new cv.Rect(t-p,a-p,v,u),P=new cv.Mat;P=E.roi(S),cv.threshold(P,P,0,255,cv.THRESH_OTSU+cv.THRESH_BINARY),cv.countNonZero(P)<U&&(_.push(t),D.push(a)),P.delete()}let C,d,l,A,w,I,x,b;if(_.length>0&&(C=_[0],d=D[1],l=_[0],A=D[1],w=_[0],I=D[1],x=_[0],b=D[1]),_.length>1)for(let s=0;s<_.length;s++){let t=_[s],a=D[s];t*t+a*a<=C*C+d*d&&(C=t,d=a),t*t+a*a>=x*x+b*b&&(x=t,b=a),(H-t)*(H-t)+a*a<=(H-l)*(H-l)+A*A&&(l=t,A=a),t*t+(M-a)*(M-a)<=w*w+(M-I)*(M-I)&&(w=t,I=a)}if(_.length>=4){let s=cv.matFromArray(4,1,cv.CV_32FC2,[r,g,n,N,W,F,T,V]),t=cv.matFromArray(4,1,cv.CV_32FC2,[C,d,l,A,w,I,x,b]),a=cv.findHomography(t,s,cv.RANSAC),R=new cv.Size(e.cols,e.rows);if(a.empty())return void console.log("homography matrix empty!");cv.warpPerspective(y,c,a,R);let f=c.clone();for(let u=0;u<t.rows;++u){let Y=15,K=new cv.Point(t.data32F[2*u],t.data32F[2*u+1]);cv.circle(y,K,Y,[0,0,255,255],1)}for(let u=0;u<s.rows;++u){let Y=15,K=new cv.Point(s.data32F[2*u],s.data32F[2*u+1]);cv.circle(e,K,Y,[0,0,255,255],1),cv.circle(f,K,Y,[0,0,255,255],1)}let v={};return v.keypoints1=O(e),v.keypoints1Width=e.size().width,v.keypoints1Height=e.size().height,v.keypoints2=O(c),v.keypoints2Width=c.size().width,v.keypoints2Height=c.size().height,v.imageCompareMatches=O(y),v.imageCompareMatchesWidth=y.size().width,v.imageCompareMatchesHeight=y.size().height,v.imageAligned=O(f),v.imageAlignedWidth=f.size().width,v.imageAlignedHeight=f.size().height,e.delete(),c.delete(),o.delete(),E.delete(),y.delete(),B.delete(),s.delete(),t.delete(),f.delete(),v}{let s=new cv.KeyPointVector,t=new cv.KeyPointVector,a=new cv.Mat,R=new cv.Mat,f=new cv.AKAZE,v=new cv.Mat,u=new cv.Mat;f.detectAndCompute(E,v,s,a),f.detectAndCompute(e,u,t,R);let S=new cv.DMatchVector,P=new cv.BFMatcher,Y=new cv.DMatchVectorVector;P.knnMatch(a,R,Y,2);for(let q=0;q<Y.size();++q){let de=Y.get(q),he=de.get(0),Me=de.get(1);he.distance<=Me.distance*parseFloat("0.7")&&S.push_back(he)}let K=new cv.Mat,ae=new cv.Scalar(0,255,0,255);cv.drawMatches(y,s,e,t,S,K,ae);let X={};X.imageCompareMatches=O(K),X.imageCompareMatchesWidth=K.size().width,X.imageCompareMatchesHeight=K.size().height;let Z=new cv.Mat,$=new cv.Mat,re=new cv.Scalar(0,255,0,255);cv.drawKeypoints(E,s,Z,re),cv.drawKeypoints(e,t,$,re),X.keypoints1=O(Z),X.keypoints1Width=Z.size().width,X.keypoints1Height=Z.size().height,X.keypoints2=O($),X.keypoints2Width=$.size().width,X.keypoints2Height=$.size().height;let Q=[],ee=[];for(let q=0;q<S.size();q++)Q.push(s.get(S.get(q).queryIdx).pt.x),Q.push(s.get(S.get(q).queryIdx).pt.y),ee.push(t.get(S.get(q).trainIdx).pt.x),ee.push(t.get(S.get(q).trainIdx).pt.y);let le=new cv.Mat(Q.length,1,cv.CV_32FC2);le.data32F.set(Q);let ce=new cv.Mat(ee.length,1,cv.CV_32FC2);ce.data32F.set(ee);let oe=cv.findHomography(le,ce,cv.RANSAC);if(oe.empty())return void console.log("homography matrix empty!");console.log("h:",oe);let J=new cv.Mat;cv.warpPerspective(E,J,oe,e.size()),X.imageAligned=O(J),X.imageAlignedWidth=J.size().width,X.imageAlignedHeight=J.size().height,J.delete(),le.delete(),ce.delete(),Z.delete(),$.delete(),K.delete(),Y.delete(),P.delete(),S.delete(),f.delete(),s.delete(),t.delete(),a.delete(),R.delete(),v.delete(),u.delete(),e.delete(),c.delete(),o.delete(),E.delete(),y.delete(),B.delete()}}(i.payload);postMessage({msg:i.msg,payload:e,uid:i.uid})}else{const e=function ue(i,e){let c=cv.matFromImageData(i),o=cv.matFromImageData(e),z=new cv.Mat,k=new cv.Mat;cv.cvtColor(o,z,cv.COLOR_BGRA2GRAY),cv.cvtColor(c,k,cv.COLOR_BGRA2GRAY);let r=new cv.KeyPointVector,g=new cv.KeyPointVector,h=new cv.Mat,n=new cv.Mat,N=new cv.AKAZE,G=new cv.Mat,W=new cv.Mat;N.detectAndCompute(z,G,r,h),N.detectAndCompute(k,W,g,n);let F=new cv.DMatchVector,p=new cv.BFMatcher,T=new cv.DMatchVectorVector;p.knnMatch(h,n,T,2);for(let C=0;C<T.size();++C){let d=T.get(C),l=d.get(0),A=d.get(1);l.distance<=A.distance*parseFloat("0.7")&&F.push_back(l)}let V=new cv.Mat,j=new cv.Scalar(0,255,0,255);cv.drawMatches(o,r,c,g,F,V,j);let m={};m.imageCompareMatches=O(V),m.imageCompareMatchesWidth=V.size().width,m.imageCompareMatchesHeight=V.size().height;let L=new cv.Mat,y=new cv.Mat,E=new cv.Scalar(0,255,0,255);cv.drawKeypoints(z,r,L,E),cv.drawKeypoints(k,g,y,E),m.keypoints1=O(L),m.keypoints1Width=L.size().width,m.keypoints1Height=L.size().height,m.keypoints2=O(y),m.keypoints2Width=y.size().width,m.keypoints2Height=y.size().height;let B=[],H=[];for(let C=0;C<F.size();C++)B.push(r.get(F.get(C).queryIdx).pt.x),B.push(r.get(F.get(C).queryIdx).pt.y),H.push(g.get(F.get(C).trainIdx).pt.x),H.push(g.get(F.get(C).trainIdx).pt.y);let M=new cv.Mat(B.length,1,cv.CV_32FC2);M.data32F.set(B);let _=new cv.Mat(H.length,1,cv.CV_32FC2);_.data32F.set(H);let D=cv.findHomography(M,_,cv.RANSAC);if(D.empty())return void console.log("homography matrix empty!");console.log("h:",D);let U=new cv.Mat;return cv.warpPerspective(o,U,D,c.size()),m.imageAligned=O(U),m.imageAlignedWidth=U.size().width,m.imageAlignedHeight=U.size().height,U.delete(),M.delete(),_.delete(),L.delete(),y.delete(),V.delete(),T.delete(),p.delete(),F.delete(),N.delete(),z.delete(),r.delete(),k.delete(),g.delete(),h.delete(),n.delete(),G.delete(),W.delete(),m}(i.payload.imageA,i.payload.imageB);postMessage({msg:i.msg,payload:e,uid:i.uid})}}(i.data);case"imageCrop":return function me(i){let e=new cv.Rect(i.payload.x,i.payload.y,i.payload.width,i.payload.height),c=new cv.Mat,o=cv.matFromImageData(i.payload.image);c=o.roi(e),postMessage({msg:i.msg,payload:O(c),uid:i.uid}),c.delete(),o.delete()}(i.data);case"nameprediction":return se(i.data,!0);case"ineprediction":return se(i.data,!1)}})})();