(()=>{"use strict";class ne{constructor(e){e?(this.alphabet="abcdefghijklmnopqrstuvwxyz",this.characters="0123456789"+this.alphabet.toUpperCase()+this.alphabet):this.characters="0123456789",this.isWarmedUp=this.loadModel(e).then().then(()=>console.info("Backend running on:",tf.getBackend()))}loadModel(e){return console.time("Load model"),e?tf.loadLayersModel("content/classifier/letteranddigitclassifier/model.json").then(c=>{this._model=c,console.timeEnd("Load model")}):tf.loadLayersModel("content/classifier/digitclassifier/model.json").then(c=>{this._model=c,console.timeEnd("Load model")})}warmUp(){console.time("Warmup"),this._model.predict(tf.randomNormal([1,28,28,1])).as1D().dataSync(),console.timeEnd("Warmup")}preprocessImage(e){const k=e.width>e.height,d=Math.round((Math.max(e.width,e.height)-Math.min(e.width,e.height))/2),m=k?[[d,d],[0,0],[0,0]]:[[0,0],[d,d],[0,0]];return tf.tidy(()=>{let v=tf.browser.fromPixels(e,1).pad(m,255);return v=tf.image.resizeBilinear(v,[24,24]).pad([[2,2],[2,2],[0,0]],255),v=tf.scalar(1).sub(v.toFloat().div(tf.scalar(255))),v.expandDims(0)})}predict(e){if(!this._model)return console.warn("Model not loaded yet!");const c=this.preprocessImage(e),o=this._model.predict(c).as1D(),z=o.argMax().dataSync()[0],k=o.max().dataSync()[0];return[this.characters[z],k]}}let te,ie;function se(i,e){let c=cv.matFromImageData(i.payload.image);const o=function pe(i){return i?(void 0===te&&(te=new ne(i)),te):(void 0===ie&&(ie=new ne(i)),ie)}(e);o.isWarmedUp.then(()=>{const z=function fe(i,e,c,o,z){const k=function ye(i,e,c){let n=i.clone(),N=new cv.Mat;cv.cvtColor(i,N,cv.COLOR_BGR2GRAY,0);let G=new cv.Mat;cv.threshold(N,G,0,255,cv.THRESH_BINARY_INV+cv.THRESH_OTSU);let W=new cv.Point(-1,-1);if(e){let l=new cv.Mat,A=new cv.Size(1,15),r=cv.getStructuringElement(cv.MORPH_RECT,A);cv.morphologyEx(G,l,cv.MORPH_OPEN,r,W,2,cv.BORDER_CONSTANT,cv.morphologyDefaultBorderValue());let I=new cv.MatVector,x=new cv.Mat;cv.findContours(l,I,x,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE);let b=new cv.Scalar(255,255,255);cv.drawContours(n,I,-1,b,4);let s=new cv.Mat,t=new cv.Size(15,1),a=cv.getStructuringElement(cv.MORPH_RECT,t),R=new cv.Point(-1,-1);cv.morphologyEx(G,s,cv.MORPH_OPEN,a,R,2,cv.BORDER_CONSTANT,cv.morphologyDefaultBorderValue());let f=new cv.MatVector,g=new cv.Mat;cv.findContours(s,f,g,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE);let u=new cv.Scalar(255,255,255);cv.drawContours(n,f,-1,u,4),l.delete(),I.delete(),x.delete(),r.delete(),s.delete(),f.delete(),g.delete(),a.delete()}let F=new cv.Size(3,3),w=cv.getStructuringElement(cv.MORPH_ELLIPSE,F),T=new cv.Mat,j=cv.Mat.ones(i.rows,i.cols,cv.CV_8UC3);j.setTo(new cv.Scalar(255,255,255)),cv.cvtColor(j,j,cv.COLOR_BGR2GRAY,0);let p=new cv.Mat;cv.cvtColor(n,p,cv.COLOR_BGR2GRAY,0);let L=new cv.Mat;cv.subtract(j,p,L,T,-1);let y=new cv.Mat;cv.dilate(L,y,w,W,3,cv.BORDER_CONSTANT,cv.morphologyDefaultBorderValue());let E=new cv.Mat,B=new cv.Mat;cv.bitwise_and(y,G,E),cv.morphologyEx(E,B,cv.MORPH_CLOSE,w,W,3,cv.BORDER_CONSTANT,cv.morphologyDefaultBorderValue());let H=new cv.Mat;cv.bitwise_and(B,G,H);let M=new cv.Mat;cv.subtract(j,H,M,T,-1);let _=new cv.MatVector,D=new cv.Mat;cv.findContours(H,_,D,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE);const U=new Map;let C=[];for(let l=0;l<_.size();l++){let A=_.get(l),r=cv.boundingRect(A);(r.width>12||r.height>12)&&(r.width>r.height?(r.y=r.y-(r.width-r.height)/2,r.height=r.width):(r.x=r.x-(r.height-r.width)/2,r.width=r.height),C.push(r))}C.forEach(l=>{let A=new cv.Scalar(0,0,0),r=new cv.Point(l.x,l.y),I=new cv.Point(l.x+l.width,l.y+l.height),x=new cv.Mat,b=new cv.Mat,s=new cv.Mat;const t=M.size().width,a=M.size().height;l.x+l.width>t&&(l.width=t-l.x),l.y+l.height>a&&(l.height=a-l.y),l.x<0&&(l.x=0),l.y<0&&(l.y=0),x=M.roi(l);let R=new cv.Size(26,26);cv.resize(x,b,R,0,0,cv.INTER_AREA);let f=new cv.Scalar(255,0,0,255);cv.copyMakeBorder(b,s,1,1,1,1,cv.BORDER_CONSTANT,f),U.set(l,s),x.delete(),b.delete(),cv.rectangle(M,r,I,A,2,cv.LINE_AA,0)}),N.delete(),G.delete(),w.delete(),T.delete(),j.delete(),p.delete(),L.delete(),y.delete(),n.delete(),E.delete(),B.delete(),H.delete(),_.delete(),D.delete();let h=[...U];if(h.sort((l,A)=>l[0].x<A[0].x?-1:1),c&&h.length>3){const l=(h[h.length-1][0].x-h[0][0].x)/h.length;let A=l,r=0,I=0,x=800;const b=[];for(let t=0;t<h.length-1;t++){let a=h[t+1][0].x-h[t][0].x;a<A&&(A=a),a>1.7*l&&b.push(t),h[t][0].y<x&&(x=h[t][0].y),h[t][0].height>r&&(r=h[t][0].height),h[t][0].width>I&&(I=h[t][0].width)}const s=(h[h.length-1][0].x-h[0][0].x)/(h.length+b.length);b.forEach(t=>{let a=h[t][0].x+s,R=new cv.Scalar(0,0,0),f=new cv.Point(a,x),g=new cv.Point(a+I,x+r),u=new cv.Rect(a,x,I,r),S=new cv.Mat,P=new cv.Mat,Y=new cv.Mat;S=M.roi(u);let K=new cv.Size(26,26);cv.resize(S,P,K,0,0,cv.INTER_AREA);let ae=new cv.Scalar(255,0,0,255);cv.copyMakeBorder(P,Y,1,1,1,1,cv.BORDER_CONSTANT,ae),U.set(u,Y),S.delete(),P.delete(),cv.rectangle(M,f,g,R,2,cv.LINE_AA,0)}),h=[...U],h.sort((t,a)=>t[0].x<a[0].x?-1:1)}return{letter:h,invert_final:M}}(i,!1,o);let d=[];e.forEach(v=>{d.push([v.padEnd(13," "),0])});const m=[];for(let v=0;v<k.letter.length;v++){let n=c.predict(O(k.letter[v][1]));z&&("1"===n[0]&&(n[0]="i"),"0"===n[0]&&(n[0]="o"),"5"===n[0]&&(n[0]="s"),"3"===n[0]&&(n[0]="b"),"9"===n[0]&&(n[0]="g")),m.push(n)}for(let v=0;v<d.length;v++){for(let n=0;n<13;n++)n<m.length&&(d[v][1]=d[v][0].substring(n,n+1).toLowerCase()===m[n][0].toLowerCase()?d[v][1]+m[n][1]:d[v][1]+(1-m[n][1])/35);d[v][1]=d[v][1]/m.length}return d.sort((v,n)=>v[1]<n[1]?1:-1),d[0][0]=d[0][0].trim(),{debug:k.invert_final,solution:d[0]}}(c,i.payload.match,o,!0,e);postMessage({msg:i.msg,payload:{debug:O(z.debug),solution:z.solution},uid:i.uid}),z.debug.delete(),c.delete()})}function O(i){const e=new cv.Mat,c=i.type()%8,o=c<=cv.CV_8S?1:c<=cv.CV_32S?1/256:255,z=c===cv.CV_8S||c===cv.CV_16S?128:0;switch(i.convertTo(e,cv.CV_8U,o,z),e.type()){case cv.CV_8UC1:cv.cvtColor(e,e,cv.COLOR_GRAY2RGBA);break;case cv.CV_8UC3:cv.cvtColor(e,e,cv.COLOR_RGB2RGBA);break;case cv.CV_8UC4:break;default:throw new Error("Bad number of channels (Source image must have 1, 3 or 4 channels)")}const k=new ImageData(new Uint8ClampedArray(e.data),e.cols,e.rows);return e.delete(),k}addEventListener("message",i=>{switch(i.data.msg){case"hello":postMessage({msg:`worker response to ${i.data.msg}`,uid:i.data.uid});break;case"load":{const e=self;e.Module={scriptUrl:"content/opencv/4/opencv.js",onRuntimeInitialized(){cv.then(c=>{cv=c,c.ready.then(()=>postMessage({msg:"opencvready",uid:i.data.uid}))})}},e.importScripts(e.Module.scriptUrl),e.importScripts("https://cdn.jsdelivr.net/npm/@tensorflow/tfjs");break}case"imageProcessing":return function ve(i){const e=cv.matFromImageData(i.payload);let c=new cv.Mat;cv.cvtColor(e,c,cv.COLOR_BGR2GRAY),postMessage({msg:i.msg,payload:O(c),uid:i.uid}),e.delete(),c.delete()}(i.data);case"imageAlignement":return function ge(i){if(i.payload.marker){const e=function we(i){let d,m,v,n,N,G,W,F,w,T,V,j,e=cv.matFromImageData(i.imageA),c=new cv.Mat,o=new cv.Mat;cv.cvtColor(e,e,cv.COLOR_RGBA2GRAY),cv.HoughCircles(e,o,cv.HOUGH_GRADIENT,1,45,75,20,6*e.cols/1e3,20*e.cols/1e3),o.cols>0&&(d=o.data32F[0],m=o.data32F[1],v=o.data32F[2],n=o.data32F[0],N=o.data32F[1],G=o.data32F[2],W=o.data32F[0],F=o.data32F[1],w=o.data32F[2],T=o.data32F[0],V=o.data32F[1],j=o.data32F[2]);const p=e.size().width,L=e.size().height;if(o.cols>0)for(let s=1;s<o.cols;s++){let t=o.data32F[3*s],a=o.data32F[3*s+1],R=o.data32F[3*s+2];t*t+a*a<=d*d+m*m&&(d=t,m=a,v=R),t*t+a*a>=T*T+V*V&&(T=t,V=a,j=R),(p-t)*(p-t)+a*a<=(p-n)*(p-n)+N*N&&(n=t,N=a,G=R),t*t+(L-a)*(L-a)<=W*W+(L-F)*(L-F)&&(W=t,F=a,w=R)}let y=cv.matFromImageData(i.imageB),E=new cv.Mat,B=new cv.Mat;cv.cvtColor(y,E,cv.COLOR_RGBA2GRAY);const H=E.size().width,M=E.size().height;cv.HoughCircles(E,B,cv.HOUGH_GRADIENT,1,45,75,15,w-3,w+3);let _=[],D=[];const U=150*(4*w*w-3.14159*w*w)/100;for(let s=0;s<B.cols;s++){let t=B.data32F[3*s],a=B.data32F[3*s+1];const R=t-w,f=a-w;let g=2*w,u=2*w;R+g>H&&(g=H-R),f+u>M&&(u=M-f);let S=new cv.Rect(t-w,a-w,g,u),P=new cv.Mat;P=E.roi(S),cv.threshold(P,P,0,255,cv.THRESH_OTSU+cv.THRESH_BINARY),cv.countNonZero(P)<U&&(_.push(t),D.push(a)),P.delete()}let C,h,l,A,r,I,x,b;if(_.length>0&&(C=_[0],h=D[1],l=_[0],A=D[1],r=_[0],I=D[1],x=_[0],b=D[1]),_.length>1)for(let s=0;s<_.length;s++){let t=_[s],a=D[s];t*t+a*a<=C*C+h*h&&(C=t,h=a),t*t+a*a>=x*x+b*b&&(x=t,b=a),(H-t)*(H-t)+a*a<=(H-l)*(H-l)+A*A&&(l=t,A=a),t*t+(M-a)*(M-a)<=r*r+(M-I)*(M-I)&&(r=t,I=a)}if(_.length>=4){let s=cv.matFromArray(4,1,cv.CV_32FC2,[d,m,n,N,W,F,T,V]),t=cv.matFromArray(4,1,cv.CV_32FC2,[C,h,l,A,r,I,x,b]),a=cv.findHomography(t,s,cv.RANSAC),R=new cv.Size(e.cols,e.rows);if(a.empty())return void console.log("homography matrix empty!");cv.warpPerspective(y,c,a,R);let f=c.clone();for(let u=0;u<t.rows;++u){let Y=15,K=new cv.Point(t.data32F[2*u],t.data32F[2*u+1]);cv.circle(y,K,Y,[0,0,255,255],1)}for(let u=0;u<s.rows;++u){let Y=15,K=new cv.Point(s.data32F[2*u],s.data32F[2*u+1]);cv.circle(e,K,Y,[0,0,255,255],1),cv.circle(f,K,Y,[0,0,255,255],1)}let g={};return g.keypoints1=O(e),g.keypoints1Width=e.size().width,g.keypoints1Height=e.size().height,g.keypoints2=O(c),g.keypoints2Width=c.size().width,g.keypoints2Height=c.size().height,g.imageCompareMatches=O(y),g.imageCompareMatchesWidth=y.size().width,g.imageCompareMatchesHeight=y.size().height,g.imageAligned=O(f),g.imageAlignedWidth=f.size().width,g.imageAlignedHeight=f.size().height,e.delete(),c.delete(),o.delete(),E.delete(),y.delete(),B.delete(),s.delete(),t.delete(),f.delete(),g}{let s=new cv.KeyPointVector,t=new cv.KeyPointVector,a=new cv.Mat,R=new cv.Mat,f=new cv.AKAZE,g=new cv.Mat,u=new cv.Mat;f.detectAndCompute(E,g,s,a),f.detectAndCompute(e,u,t,R);let S=new cv.DMatchVector,P=new cv.BFMatcher,Y=new cv.DMatchVectorVector;P.knnMatch(a,R,Y,2);for(let q=0;q<Y.size();++q){let de=Y.get(q),he=de.get(0),Me=de.get(1);he.distance<=Me.distance*parseFloat("0.7")&&S.push_back(he)}let K=new cv.Mat,ae=new cv.Scalar(0,255,0,255);cv.drawMatches(y,s,e,t,S,K,ae);let X={};X.imageCompareMatches=O(K),X.imageCompareMatchesWidth=K.size().width,X.imageCompareMatchesHeight=K.size().height;let Z=new cv.Mat,$=new cv.Mat,re=new cv.Scalar(0,255,0,255);cv.drawKeypoints(E,s,Z,re),cv.drawKeypoints(e,t,$,re),X.keypoints1=O(Z),X.keypoints1Width=Z.size().width,X.keypoints1Height=Z.size().height,X.keypoints2=O($),X.keypoints2Width=$.size().width,X.keypoints2Height=$.size().height;let Q=[],ee=[];for(let q=0;q<S.size();q++)Q.push(s.get(S.get(q).queryIdx).pt.x),Q.push(s.get(S.get(q).queryIdx).pt.y),ee.push(t.get(S.get(q).trainIdx).pt.x),ee.push(t.get(S.get(q).trainIdx).pt.y);let le=new cv.Mat(Q.length,1,cv.CV_32FC2);le.data32F.set(Q);let ce=new cv.Mat(ee.length,1,cv.CV_32FC2);ce.data32F.set(ee);let oe=cv.findHomography(le,ce,cv.RANSAC);if(oe.empty())return void console.log("homography matrix empty!");console.log("h:",oe);let J=new cv.Mat;cv.warpPerspective(E,J,oe,e.size()),X.imageAligned=O(J),X.imageAlignedWidth=J.size().width,X.imageAlignedHeight=J.size().height,J.delete(),le.delete(),ce.delete(),Z.delete(),$.delete(),K.delete(),Y.delete(),P.delete(),S.delete(),f.delete(),s.delete(),t.delete(),a.delete(),R.delete(),g.delete(),u.delete(),e.delete(),c.delete(),o.delete(),E.delete(),y.delete(),B.delete()}}(i.payload);postMessage({msg:i.msg,payload:e,uid:i.uid})}else{const e=function ue(i,e){let c=cv.matFromImageData(i),o=cv.matFromImageData(e),z=new cv.Mat,k=new cv.Mat;cv.cvtColor(o,z,cv.COLOR_BGRA2GRAY),cv.cvtColor(c,k,cv.COLOR_BGRA2GRAY);let d=new cv.KeyPointVector,m=new cv.KeyPointVector,v=new cv.Mat,n=new cv.Mat,N=new cv.AKAZE,G=new cv.Mat,W=new cv.Mat;N.detectAndCompute(z,G,d,v),N.detectAndCompute(k,W,m,n);let F=new cv.DMatchVector,w=new cv.BFMatcher,T=new cv.DMatchVectorVector;w.knnMatch(v,n,T,2);for(let C=0;C<T.size();++C){let h=T.get(C),l=h.get(0),A=h.get(1);l.distance<=A.distance*parseFloat("0.7")&&F.push_back(l)}let V=new cv.Mat,j=new cv.Scalar(0,255,0,255);cv.drawMatches(o,d,c,m,F,V,j);let p={};p.imageCompareMatches=O(V),p.imageCompareMatchesWidth=V.size().width,p.imageCompareMatchesHeight=V.size().height;let L=new cv.Mat,y=new cv.Mat,E=new cv.Scalar(0,255,0,255);cv.drawKeypoints(z,d,L,E),cv.drawKeypoints(k,m,y,E),p.keypoints1=O(L),p.keypoints1Width=L.size().width,p.keypoints1Height=L.size().height,p.keypoints2=O(y),p.keypoints2Width=y.size().width,p.keypoints2Height=y.size().height;let B=[],H=[];for(let C=0;C<F.size();C++)B.push(d.get(F.get(C).queryIdx).pt.x),B.push(d.get(F.get(C).queryIdx).pt.y),H.push(m.get(F.get(C).trainIdx).pt.x),H.push(m.get(F.get(C).trainIdx).pt.y);let M=new cv.Mat(B.length,1,cv.CV_32FC2);M.data32F.set(B);let _=new cv.Mat(H.length,1,cv.CV_32FC2);_.data32F.set(H);let D=cv.findHomography(M,_,cv.RANSAC);if(D.empty())return void console.log("homography matrix empty!");console.log("h:",D);let U=new cv.Mat;return cv.warpPerspective(o,U,D,c.size()),p.imageAligned=O(U),p.imageAlignedWidth=U.size().width,p.imageAlignedHeight=U.size().height,U.delete(),M.delete(),_.delete(),L.delete(),y.delete(),V.delete(),T.delete(),w.delete(),F.delete(),N.delete(),z.delete(),d.delete(),k.delete(),m.delete(),v.delete(),n.delete(),G.delete(),W.delete(),p}(i.payload.imageA,i.payload.imageB);postMessage({msg:i.msg,payload:e,uid:i.uid})}}(i.data);case"imageCrop":return function me(i){let e=new cv.Rect(i.payload.x,i.payload.y,i.payload.width,i.payload.height),c=new cv.Mat,o=cv.matFromImageData(i.payload.image);c=o.roi(e),postMessage({msg:i.msg,payload:O(c),uid:i.uid}),c.delete(),o.delete()}(i.data);case"nameprediction":return se(i.data,!0);case"ineprediction":return se(i.data,!1)}})})();